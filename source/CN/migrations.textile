h2. Rails 数据库迁移(Migrations)

Migrations are a convenient way for you to alter your database in a structured
and organized manner. You could edit fragments of SQL by hand but you would then
be responsible for telling other developers that they need to go and run them.
You'd also have to keep track of which changes need to be run against the
production machines next time you deploy.

Active Record tracks which migrations have already been run so all you have to
do is update your source and run +rake db:migrate+. Active Record will work out
which migrations should be run. It will also update your +db/schema.rb+ file to
match the structure of your database.

Migrations also allow you to describe these transformations using Ruby. The
great thing about this is that (like most of Active Record's functionality) it
is database independent: you don't need to worry about the precise syntax of
+CREATE TABLE+ any more than you worry about variations on +SELECT *+ (you can
drop down to raw SQL for database specific features). For example you could use
SQLite3 in development, but MySQL in production.

在这个指南中，你将会了解到：

* 你可以用于创建migration的生成器
* Active Record 所提供用于操纵数据库的方法
* 用于操纵migrations的Rake任务
* Migrations跟数据库模式文件（+schema.rb+）的关联


h3. 剖析一个Migration

在我们深入介绍migration的细节之前，我们先看下列例子看下我们能怎么写migration:

<ruby>
class CreateProducts < ActiveRecord::Migration
  def up
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end

  def down
    drop_table :products
  end
end
</ruby>

这个migration建立了一张叫+products+的数据库表，这张表中包含一个名为+name+的string
类型字段和一个名为+description+的text类型字段。一个名为+id+的字段也同时被添加，
这个字段是默认添加的因而我们不需要另外请求。另外Active Record所需要的时间戳
(timestamp)字段(create_at和update_at)也会被自动添加。而要取消这个migration只需
简单地把这张表删除掉即可。

Migrations不仅用于修改数据库架构。你还可以用它来修复数据库中的错误数据或者添加新
字段。

<ruby>
class AddReceiveNewsletterToUsers < ActiveRecord::Migration
  def up
    change_table :users do |t|
      t.boolean :receive_newsletter, :default => false
    end
    User.update_all ["receive_newsletter = ?", true]
  end

  def down
    remove_column :users, :receive_newsletter
  end
end
</ruby>

/*TODO*/
NOTE: Some "caveats":#using-models-in-your-migrations apply to using models in
your migrations.

这个migration为+users+表添加了一个+receive_newsletter+字段，并设定新的user创建
时它的默认值为+false+，对于数据库中已存在的users我们使用User模型来把他们的这个
标志位设为true。

Rails 3.1为migrations提供了<tt>change</tt>方法使它变得更精简。这个方法主要用于一
些构造性的migrations（例如添加新字段或者新的表），它能知道怎么样迁移你的数据库
并在你需要回滚的时候恢复回去而并不需要写一个分开的down方法。

<ruby>
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
</ruby>

h4. Migrations也是类

Migration是继承<tt>ActiveRecord::Migration</tt>的一个子类，它实现了两个方法：
+up+(执行需要的改变)和+down+(恢复所做的改变)

Active Record provides methods that perform common data definition tasks in a
database independent way (you'll read about them in detail later):
Active Record提供一些用于执行普通数据定义任务的方法(你稍后将会了解到它们的细节):

* +add_column+
* +add_index+
* +change_column+
* +change_table+
* +create_table+
* +create_join_table+
* +drop_table+
* +remove_column+
* +remove_index+
* +rename_column+

如果你需要为你的数据库完成一些特殊的任务（例如创建一个强制的"外键":#active-record-and-referential-integrity ），
这时候+execute+方法允许你执行任意的SQL语句。一个migration同时也是一个规则的Ruby类，
因而你不限于使用以上的方法。例如在添加完新字段后你可以编写代码去为数据库中已经
存在的记录设定这个字段的值(有需要的话利用你的models)。

On databases that support transactions with statements that change the schema
(such as PostgreSQL or SQLite3), migrations are wrapped in a transaction. If the
database does not support this (for example MySQL) then when a migration fails
the parts of it that succeeded will not be rolled back. You will have to rollback
the changes that were made by hand.
/*TODO*/
在数据库中支持一些修改数据库模式(schema)的处理，migrations包裹在事务中

h4. 关于文件名

Migrations是以文件形式存储在+db/migrate+目录中，每一个migration都作为一个文件。
文件名的格式为+YYYYMMDDHHMMSS_create_products.rb+，文件名前面是一个UTC时间截，
接下来以下划线连接migration的名称。migration的类名是遵循驼峰式命名格式，它跟
文件名的后半部分是一样的。例如+20080906120000_create_products.rb+这一个migration
应该定义了一个名为+CreateProducts+的类，而+20080906120001_add_details_to_products.rb+
则定义了一个+AddDetailsToProducts+的类。如果你需要修改文件名，你就<em>必须</em>
修改文件中的类名，不然会报missing class的错误。

Rails内部在辨别migration的时候只会用到编号（前面的时间截）的部分。在Rails2.1之前
的版本，migration的编号是从1开始递增的，这样做法，在多人开发时很容易造成编号冲突，
一旦冲突了就需要将migration回滚(rollback)并重新编号。如果你坚持想要用回原来的这种
编号结构，可以在+config/application.rb+中加入下面这一行。

<ruby>
config.active_record.timestamped_migrations = false
</ruby>

通过时间截和记录已执行过哪些migrations的特性，让Rails能够应付多人开发的状况。

举例来说：爱丽丝新增了+20080906120000+和+20080906123000+这两个migration，而鲍勃
接下来新增了+20080906124500+并执行了它。当艾丽丝完成并提交后，鲍勃同步了最新的
代码。这时鲍勃执行+rake db:migrate+，虽然鲍勃新增的migraion的时间截比较新，但
Rails会知道艾丽丝的这两个migration还没执行，它会自动执行对应的方法。

Of course this is no substitution for communication within the team. For
example, if Alice's migration removed a table that Bob's migration assumed to
exist, then trouble would certainly strike.
当然，团队内的沟通是必不可少的。例如爱丽丝的migration移除了鲍勃的migration会用到
的表，那肯定会出问题的。

h4. 变更 Migrations

有时你在写migration的时候可能会不小心写错，如果你已经执行了这个migration，那么，
你就不能单纯地把它修改一下再重新执行一次，Rails会认为这个migration已经执行过了，
所以执行+rake db:migrate+时不会做任何操作。你应该先把写错的那个migration回滚回来
（可以执行 +rake db:rollback+），然后修改你的migration再执行+rake db:migrate+去
执行正确的版本。

一般来说，最好不要修改现有的migrations，因为这样做可能会会为你跟你的同事带来很多
麻烦，特别是这个migration已经在正式上线的服务器上执行过的话。你应该写一个新的
migration来做数据库变更。如果这个migration还没有进入版本控制（也就是说这些变更还
没有发布出去），那么直接修改还是可以的。

h4. Supported Types

Active Record supports the following database column types:

* +:binary+
* +:boolean+
* +:date+
* +:datetime+
* +:decimal+
* +:float+
* +:integer+
* +:primary_key+
* +:string+
* +:text+
* +:time+
* +:timestamp+

These will be mapped onto an appropriate underlying database type. For example,
with MySQL the type +:string+ is mapped to +VARCHAR(255)+. You can create
columns of types not supported by Active Record when using the non-sexy syntax,
for example

<ruby>
create_table :products do |t|
  t.column :name, 'polygon', :null => false
end
</ruby>

This may however hinder portability to other databases.

h3. 创建一个 Migration

h4. 建立一个 Model

Model和 scaffold的generators(生成器)在新建model的时候会自动生成对应的migration。
这个migraion里已经把建立数据表的步骤都写好了。如果生成的时候告诉Rails需要哪些字
段，Rails会把新增字段的代码都一起生成好。例如执行以下代码

<shell>
$ rails generate model Product name:string description:text
</shell>

将会生成的migration如下:

<ruby>
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
</ruby>

如果有需要的话你可以追加更多的"名称/类型"字段。默认会生成的migration都会包含
+t.timestamps+（这个会生成+updated_at+和+created_at+字段，而Active Record会在
新增数据和更新时自动更新时间）。

h4. 建立一个独立的 Migration

如果你建立migrations不是为了新增model，而是为了其他目的（例如为现在的数据库表添加
字段），那可以只用migration的生成器：

<shell>
$ rails generate migration AddPartNumberToProducts
</shell>

这样会建立一个空白的但已经命名好的migration:

<ruby>
class AddPartNumberToProducts < ActiveRecord::Migration
  def change
  end
end
</ruby>

如果migration的文件名命名为"AddXXXToYYY"或"RemoveXXXFromYYY"这类格式，后面再加上
一串字段名和类型的清单，那么这个migration就会含有对应的+add_column+和+remove_column+
语句。

<shell>
$ rails generate migration AddPartNumberToProducts part_number:string
</shell>

将会生成：

<ruby>
class AddPartNumberToProducts < ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
  end
end
</ruby>

类似的，

<shell>
$ rails generate migration RemovePartNumberFromProducts part_number:string
</shell>

则生成：

<ruby>
class RemovePartNumberFromProducts < ActiveRecord::Migration
  def up
    remove_column :products, :part_number
  end

  def down
    add_column :products, :part_number, :string
  end
end
</ruby>

这种方法可以操作多个字段，例如：

<shell>
$ rails generate migration AddDetailsToProducts part_number:string price:decimal
</shell>

将会生成：

<ruby>
class AddDetailsToProducts < ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
</ruby>

通常来说，这些自动生成的migration只是起点，我们接下来可以直接修改文件直到我们满意。

NOTE: The generated migration file for destructive migrations will still be
old-style using the +up+ and +down+ methods. This is because Rails needs to know
the original data types defined when you made the original changes.

h3. 编写一个 Migration

当你建立一个migration文件时，接下来就是我们要做的了。

h4. 建立数据表

一般要建立数据表可以用migration的create_table方法。典型的用法如下：

<ruby>
create_table :products do |t|
  t.string :name
end
</ruby>

这样会建立了一个名为+products+的数据表，里面包含一个名为name的字段（如之前所说，
这里也会自动加上一个+id+字段）。

这段代码块可以让你在数据表中新增字段。新增的的方法有格式，第一种，也是相对传统的
写法，如下：

<ruby>
create_table :products do |t|
  t.column :name, :string, :null => false
end
</ruby>

第二种格式，就是所谓的"sexy"写法，把column去掉了，用+string+和+integer+等方法来
建立对应类型的字段。至于在后面添加的参数是一样的。

<ruby>
create_table :products do |t|
  t.string :name, :null => false
end
</ruby>

默认在+create_table+时新增的主键名为+id+，要改主键的名称，你需要加上+:primary_key+
这个选项（不要忘了更新对应model的格式）。如果你根本就不要主键（例如使用多对多连接
HABTM的数据表时），那就传入+:id => false+。另外，如果要传入某个特定数据表的设定，
你可以在+:options+选项中加上一个SQL片段。例如：

<ruby>
create_table :products, :options => "ENGINE=BLACKHOLE" do |t|
  t.string :name, :null => false
end
</ruby>

这样在建立数据表的SQL语句中就会加入+ENGINE=BLACKHOLE+。（如果是用MySQL的话，预设
是+ENGINE=InnoDB+）

h4. Creating a Join Table

Migration method +create_join_table+ creates a HABTM join table. A typical use
would be

<ruby>
create_join_table :products, :categories
</ruby>

which creates a +categories_products+ table with two columns called +category_id+ and +product_id+.
These columns have the option +:null+ set to +false+ by default.

You can pass the option +:table_name+ with you want to customize the table name. For example,

<ruby>
create_join_table :products, :categories, :table_name => :categorization
</ruby>

will create a +categorization+ table.

By default, +create_join_table+ will create two columns with no options, but you can specify these
options using the +:column_options+ option. For example,

<ruby>
create_join_table :products, :categories, :column_options => {:null => true}
</ruby>

will create the +product_id+ and +category_id+ with the +:null+ option as +true+.

h4. 变更数据表

要变更现有的数据表，可以用+create_table+的类似方法+change_table+。它的用法跟
+create_table+差不多，但它的代码块有更多的方式。例如：

<ruby>
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
</ruby>

移除了两个字段+description+和+name+，创建了一个+part_number+的字符串类型字段并
为其添加了索引。最后重命名了+upccode+字段。

h4. 特殊方法

有些功能很常用，例如+created_at+和+updated_at+字段，为此，Active Record提供了一
些捷径：

<ruby>
create_table :products do |t|
  t.timestamps
end
</ruby>

以上会建立一个新的products数据表，并包含+created_at+和+updated_at+字段(当然还有id)。
此外：

<ruby>
change_table :products do |t|
  t.timestamps
end
</ruby>
则会在原来的数据表中加入这两个字段。

另一个特殊的方法是+references+（也可以写成+belongs_to+）。它最基本的的功能就是
增加可读性。

<ruby>
create_table :products do |t|
  t.references :category
end
</ruby>

以上会建立一个+category_id+的字段，并给它一个适当的类型。要注意这里要输入的是model
的名称而不是字段名。Active Record会自动在model名称的后面加上+_id+。若你需要用到
多态的+belongs_to+关联时，那么+references+会把两个所需的字段都加进去。

<ruby>
create_table :products do |t|
  t.references :attachment, :polymorphic => {:default => 'Photo'}
end
</ruby>

以上会建立一个+attachment_id+字段和一个默认值为'Photo'的+attachment_type+字段。

NOTE: The +references+ helper does not actually create foreign key constraints
for you. You will need to use +execute+ or a plugin that adds "foreign key
support":#active-record-and-referential-integrity.

If the helpers provided by Active Record aren't enough you can use the +execute+
method to execute arbitrary SQL.

For more details and examples of individual methods, check the API documentation,
in particular the documentation for
"<tt>ActiveRecord::ConnectionAdapters::SchemaStatements</tt>":http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html
(which provides the methods available in the +up+ and +down+ methods),
"<tt>ActiveRecord::ConnectionAdapters::TableDefinition</tt>":http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html
(which provides the methods available on the object yielded by +create_table+)
and
"<tt>ActiveRecord::ConnectionAdapters::Table</tt>":http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html
(which provides the methods available on the object yielded by +change_table+).

h4. Using the +change+ Method

The +change+ method removes the need to write both +up+ and +down+ methods in
those cases that Rails know how to revert the changes automatically. Currently,
the +change+ method supports only these migration definitions:

* +add_column+
* +add_index+
* +add_timestamps+
* +create_table+
* +remove_timestamps+
* +rename_column+
* +rename_index+
* +rename_table+

If you're going to need to use any other methods, you'll have to write the
+up+ and +down+ methods instead of using the +change+ method.

h4. Using the +up+/+down+ Methods

The +down+ method of your migration should revert the transformations done by
the +up+ method. In other words, the database schema should be unchanged if you
do an +up+ followed by a +down+. For example, if you create a table in the +up+
method, you should drop it in the +down+ method. It is wise to reverse the
transformations in precisely the reverse order they were made in the +up+
method. For example,

<ruby>
class ExampleMigration < ActiveRecord::Migration
  def up
    create_table :products do |t|
      t.references :category
    end
    #add a foreign key
    execute <<-SQL
      ALTER TABLE products
        ADD CONSTRAINT fk_products_categories
        FOREIGN KEY (category_id)
        REFERENCES categories(id)
    SQL
    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end

  def down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url
    execute <<-SQL
      ALTER TABLE products
        DROP FOREIGN KEY fk_products_categories
    SQL
    drop_table :products
  end
end
</ruby>

Sometimes your migration will do something which is just plain irreversible; for
example, it might destroy some data. In such cases, you can raise
+ActiveRecord::IrreversibleMigration+ from your +down+ method. If someone tries
to revert your migration, an error message will be displayed saying that it
can't be done.

h3. Running Migrations

Rails provides a set of rake tasks to work with migrations which boil down to
running certain sets of migrations.

The very first migration related rake task you will use will probably be
+rake db:migrate+. In its most basic form it just runs the +up+ or +change+
method for all the migrations that have not yet been run. If there are
no such migrations, it exits. It will run these migrations in order based
on the date of the migration.

Note that running the +db:migrate+ also invokes the +db:schema:dump+ task, which
will update your db/schema.rb file to match the structure of your database.

If you specify a target version, Active Record will run the required migrations
(up, down or change) until it has reached the specified version. The version
is the numerical prefix on the migration's filename. For example, to migrate
to version 20080906120000 run

<shell>
$ rake db:migrate VERSION=20080906120000
</shell>

If version 20080906120000 is greater than the current version (i.e., it is
migrating upwards), this will run the +up+ method on all migrations up to and
including 20080906120000, and will not execute any later migrations. If
migrating downwards, this will run the +down+ method on all the migrations
down to, but not including, 20080906120000.

h4. Rolling Back

A common task is to rollback the last migration, for example if you made a
mistake in it and wish to correct it. Rather than tracking down the version
number associated with the previous migration you can run

<shell>
$ rake db:rollback
</shell>

This will run the +down+ method from the latest migration. If you need to undo
several migrations you can provide a +STEP+ parameter:

<shell>
$ rake db:rollback STEP=3
</shell>

will run the +down+ method from the last 3 migrations.

The +db:migrate:redo+ task is a shortcut for doing a rollback and then migrating
back up again. As with the +db:rollback+ task, you can use the +STEP+ parameter
if you need to go more than one version back, for example

<shell>
$ rake db:migrate:redo STEP=3
</shell>

Neither of these Rake tasks do anything you could not do with +db:migrate+. They
are simply more convenient, since you do not need to explicitly specify the
version to migrate to.

h4. Resetting the database

The +rake db:reset+ task will drop the database, recreate it and load the
current schema into it.

NOTE: This is not the same as running all the migrations - see the section on
"schema.rb":#schema-dumping-and-you.

h4. Running specific migrations

If you need to run a specific migration up or down, the +db:migrate:up+ and
+db:migrate:down+ tasks will do that. Just specify the appropriate version and
the corresponding migration will have its +up+ or +down+ method invoked, for
example,

<shell>
$ rake db:migrate:up VERSION=20080906120000
</shell>

will run the +up+ method from the 20080906120000 migration. These tasks still
check whether the migration has already run, so for example +db:migrate:up
VERSION=20080906120000+ will do nothing if Active Record believes that
20080906120000 has already been run.

h4. Changing the output of running migrations

By default migrations tell you exactly what they're doing and how long it took.
A migration creating a table and adding an index might produce output like this

<shell>
==  CreateProducts: migrating =================================================
-- create_table(:products)
   -> 0.0028s
==  CreateProducts: migrated (0.0028s) ========================================
</shell>

Several methods are provided in migrations that allow you to control all this:

|_.Method             |_.Purpose|
|suppress_messages    |Takes a block as an argument and suppresses any output
                       generated by the block.|
|say                  |Takes a message argument and outputs it as is. A second
                       boolean argument can be passed to specify whether to
                       indent or not.|
|say_with_time        |Outputs text along with how long it took to run its
                       block. If the block returns an integer it assumes it
                       is the number of rows affected.|

For example, this migration

<ruby>
class CreateProducts < ActiveRecord::Migration
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end
    say "Created a table"
    suppress_messages {add_index :products, :name}
    say "and an index!", true
    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end
</ruby>

generates the following output

<shell>
==  CreateProducts: migrating =================================================
-- Created a table
   -> and an index!
-- Waiting for a while
   -> 10.0013s
   -> 250 rows
==  CreateProducts: migrated (10.0054s) =======================================
</shell>

If you want Active Record to not output anything, then running +rake db:migrate
VERBOSE=false+ will suppress all output.

h3. Using Models in Your Migrations

When creating or updating data in a migration it is often tempting to use one of
your models. After all, they exist to provide easy access to the underlying
data. This can be done, but some caution should be observed.

For example, problems occur when the model uses database columns which are (1)
not currently in the database and (2) will be created by this or a subsequent
migration.

Consider this example, where Alice and Bob are working on the same code base
which contains a +Product+ model:

Bob goes on vacation.

Alice creates a migration for the +products+ table which adds a new column and
initializes it.  She also adds a validation to the +Product+ model for the new
column.

<ruby>
# db/migrate/20100513121110_add_flag_to_product.rb

class AddFlagToProduct < ActiveRecord::Migration
  def change
    add_column :products, :flag, :boolean
    Product.all.each do |product|
      product.update_attributes!(:flag => 'false')
    end
  end
end
</ruby>

<ruby>
# app/model/product.rb

class Product < ActiveRecord::Base
  validates :flag, :presence => true
end
</ruby>

Alice adds a second migration which adds and initializes another column to the
+products+ table and also adds a validation to the +Product+ model for the new
column.

<ruby>
# db/migrate/20100515121110_add_fuzz_to_product.rb

class AddFuzzToProduct < ActiveRecord::Migration
  def change
    add_column :products, :fuzz, :string
    Product.all.each do |product|
      product.update_attributes! :fuzz => 'fuzzy'
    end
  end
end
</ruby>

<ruby>
# app/model/product.rb

class Product < ActiveRecord::Base
  validates :flag, :fuzz, :presence => true
end
</ruby>

Both migrations work for Alice.

Bob comes back from vacation and:

# Updates the source - which contains both migrations and the latests version of
the Product model.
# Runs outstanding migrations with +rake db:migrate+, which
includes the one that updates the +Product+ model.

The migration crashes because when the model attempts to save, it tries to
validate the second added column, which is not in the database when the _first_
migration runs:

<plain>
rake aborted!
An error has occurred, this and all later migrations canceled:

undefined method `fuzz' for #<Product:0x000001049b14a0>
</plain>

A fix for this is to create a local model within the migration. This keeps rails
from running the validations, so that the migrations run to completion.

When using a faux model, it's a good idea to call
+Product.reset_column_information+ to refresh the +ActiveRecord+ cache for the
+Product+ model prior to updating data in the database.

If Alice had done this instead, there would have been no problem:

<ruby>
# db/migrate/20100513121110_add_flag_to_product.rb

class AddFlagToProduct < ActiveRecord::Migration
  class Product < ActiveRecord::Base
  end

  def change
    add_column :products, :flag, :integer
    Product.reset_column_information
    Product.all.each do |product|
      product.update_attributes!(:flag => false)
    end
  end
end
</ruby>

<ruby>
# db/migrate/20100515121110_add_fuzz_to_product.rb

class AddFuzzToProduct < ActiveRecord::Migration
  class Product < ActiveRecord::Base
  end

  def change
    add_column :products, :fuzz, :string
    Product.reset_column_information
    Product.all.each do |product|
      product.update_attributes!(:fuzz => 'fuzzy')
    end
  end
end
</ruby>

h3. Schema Dumping and You

h4. What are Schema Files for?

Migrations, mighty as they may be, are not the authoritative source for your
database schema. That role falls to either +db/schema.rb+ or an SQL file which
Active Record generates by examining the database. They are not designed to be
edited, they just represent the current state of the database.

There is no need (and it is error prone) to deploy a new instance of an app by
replaying the entire migration history. It is much simpler and faster to just
load into the database a description of the current schema.

For example, this is how the test database is created: the current development
database is dumped (either to +db/schema.rb+ or +db/structure.sql+) and then
loaded into the test database.

Schema files are also useful if you want a quick look at what attributes an
Active Record object has. This information is not in the model's code and is
frequently spread across several migrations, but the information is nicely
summed up in the schema file. The
"annotate_models":https://github.com/ctran/annotate_models gem automatically
adds and updates comments at the top of each model summarizing the schema if
you desire that functionality.

h4. Types of Schema Dumps

There are two ways to dump the schema. This is set in +config/application.rb+ by
the +config.active_record.schema_format+ setting, which may be either +:sql+ or
+:ruby+.

If +:ruby+ is selected then the schema is stored in +db/schema.rb+. If you look
at this file you'll find that it looks an awful lot like one very big migration:

<ruby>
ActiveRecord::Schema.define(:version => 20080906171750) do
  create_table "authors", :force => true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", :force => true do |t|
    t.string   "name"
    t.text "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string "part_number"
  end
end
</ruby>

In many ways this is exactly what it is. This file is created by inspecting the
database and expressing its structure using +create_table+, +add_index+, and so
on. Because this is database-independent, it could be loaded into any database
that Active Record supports. This could be very useful if you were to distribute
an application that is able to run against multiple databases.

There is however a trade-off: +db/schema.rb+ cannot express database specific
items such as foreign key constraints, triggers, or stored procedures. While in
a migration you can execute custom SQL statements, the schema dumper cannot
reconstitute those statements from the database. If you are using features like
this, then you should set the schema format to +:sql+.

Instead of using Active Record's schema dumper, the database's structure will be
dumped using a tool specific to the database (via the +db:structure:dump+ Rake task)
into +db/structure.sql+. For example, for the PostgreSQL RDBMS, the
+pg_dump+ utility is used. For MySQL, this file will contain the output of +SHOW
CREATE TABLE+ for the various tables. Loading these schemas is simply a question
of executing the SQL statements they contain. By definition, this will create a
perfect copy of the database's structure. Using the +:sql+ schema format will,
however, prevent loading the schema into a RDBMS other than the one used to
create it.

h4. Schema Dumps and Source Control

Because schema dumps are the authoritative source for your database schema, it
is strongly recommended that you check them into source control.

h3. Active Record and Referential Integrity

The Active Record way claims that intelligence belongs in your models, not in
the database. As such, features such as triggers or foreign key constraints,
which push some of that intelligence back into the database, are not heavily
used.

Validations such as +validates :foreign_key, :uniqueness => true+ are one way in
which models can enforce data integrity. The +:dependent+ option on associations
allows models to automatically destroy child objects when the parent is
destroyed. Like anything which operates at the application level, these cannot
guarantee referential integrity and so some people augment them with foreign key
constraints in the database.

Although Active Record does not provide any tools for working directly with such
features, the +execute+ method can be used to execute arbitrary SQL. You could
also use some plugin like "foreigner":https://github.com/matthuhiggins/foreigner
which add foreign key support to Active Record (including support for dumping
foreign keys in +db/schema.rb+).
