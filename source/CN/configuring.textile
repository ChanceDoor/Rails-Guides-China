h2. 配置 Rails 应用程序程序

这个指南覆盖了Rails应用程序可以使用的配置和初始化设置.通过浏览这个指南,你将能:

* 控制Rails应用程序的行为
* 添加在程序启动时运行的代码

h3. 初始化代码的为止

Rails 提供四个标准的位置防止初始化代码

* +config/application.rb+
* 运行环境相关的配置文件
* 各初始化文件
* 初始化后运行文件

h3. 先于Rails运行代码

有时候你需要在 Rails 加载自己之前运行代码, 将调入代码放在 +config/application.rb+ 文件的 +require 'rails/all'+ 之上.

h3. 配置 Rails 组件

一般而言, 配置Rails的工作其实就是配置Rails的组件, 就像配置Rails本身一样. 配置文件+config/application.rb+ 和运行环境相关的配置文件(比如 +config/environments/production.br+) 可以让你设定一些你想传递给所有组件的设置.

例如, 缺省的 +config/application.rb+ 文件包括这个设置:

<ruby>
config.filter_parameters += [:password]
</ruby>

这是给Rails本身的设置. 如果你想向单独的Rails组件传递设置, 你同样可以在+config/application.rb+文件里通过同一个+config+对象做一样的操作.

<ruby>
config.active_record.observers = [:hotel_observer, :review_observer]
</ruby>

Rails 将会使用那些特定的设置来配置Active Record.

h4. 一般的Rails配置

这些配置方法都是由 +Rails::Railtie+ 对象调用的,比如+Rails::Engine+或者+Rails::Application+.

* +config.after_initialize+ 会接受一个闭包,这个闭包将会在Rails初始化应用程序完毕_之后_再运行. 那包括框架自身, 引擎和在+config/initializers+里的所有应用程序的初始化程序的初始化.请注意这个闭包_将会_在rake任务被运行. 在给其他初始化程序配置初始值时会很有用:

<ruby>
config.after_initialize do
  ActionView::Base.sanitized_allowed_tags.delete 'div'
end
</ruby>

* +config.allow_concurrency+ 应该设置为 true 来处理同时运行(线程安全)的动作. False 为缺省值. 你也许不会想要直接调用它, 然而,因为要让线程安全模式运行的很好而做一系列其它的调整.也可以通过+threadsafe!+来激活.

* +config.asset_host+ 用于设置资源主机. 当CDNs被使用于自己的资源主机,或者当你想用不同的域名别名来解决浏览器内建线程并发限制时会很有用.这是+config.action_controller.asset_host+ 更简短的版本

* +config.asset_path+ 让你不是资源的路径.可以是一个可调用的对象, 一个字符串,或者是缺省值+nil+. 例如, +blog.js+ 通常的路径会是 +/javascript/blog.js+, 让那绝对路径为 +path+. 如果 +config.asset_path+ 是个可调用的对象, Rails 在生成资源路径的时候调用它,并向它投递+path+参数. 如果 +config.asset_path+ 是个字符串, 它应该是个带有 +%s+ 的 +sprintf+ 格式的字符串, +path+ 会插入到 +%s+ 的位置. 在任何情况下, Rails 输出布置好的路径. 这是 +config.action_controller.asset_path+简短版本.

<ruby>
config.asset_path = proc { |path| "/blog/public#{path}" }
</ruby>

注意. 如果开启了资源通道(asset pipeline), +config.asset_path+ 配置会被忽略. 默认是开启资源通道的.

* +config.autoload_once_paths+ 接受一个路径数组, 这些是Rails将会自动加载的常量的路径,所以这些常量就不会在每次请求时都被清除. 如果+config.cache_classes+是false, 这个配置将会无效, 这在开发环境下是默认的. 另外, 所有的自动加载都是发生一次. 数组所有的元素必须同时在 +autoload_paths+里.默认是空数据.

* +config.autoload_paths+ 接受一个路径数组, 这些是Rails将会自动加载的常量的路径. 默认所有+app+目录下的所有目录.

* +config.action_view.cache_template_loading+ 控制模板是否在每个请求都要被重新加载. 默认是 +config.cache_classes+ 设置的任何值.

* +config.cache_store+ 配置Rails缓存要使用什么缓存存储. 可选包括 +:memory_store+, +:file_store+, +:mem_cache_store+ 这些符号的其中一个, 有或者是实现了缓存API的一个对象. 默认是 +:file_store+如果目录 +tmp/cache+ 存在, 或者是 +:memory_store+.

* +config.colorize_logging+ 指定记录日志信息是否使用ANSI颜色码.默认是 true.

* +config.consider_all_requests_local+ 是个标记. 如果为 true 则任何携带详细调试信息的错误信息都会被放置到 HTTP 回应(response) 里, 并且 +Rails::Info+ 控制器会显示应用运行时上下文到 +/rails/info/properties+文件里的. 在开发和测试模式默认是true, 在生产模式是 false. 为了更细致的控制, 将其设置为 false 并在控制器里实现+local_request?+来指定哪些请求的错误信息需要提供调式信息.

* +config.dependency_loading+ 是个标志. 将其设置为 false 可以使自动加载常量失效. 它只在 +config.cache_classes+ 为 true 的时候才有效, 这在生产模式是默认的. 这个标志会被 +config.threadsafe!+ 设置为 false.

* +config.eager_load_paths+ 接受一个路径数组, 这些路径来自Rails会在启动时即时加载的对象(常量), 如果 +config.cache_classes+ 有开启的话. 默认是应用程序 +app+ 目录下的所有目录.

* +config.encoding+ 设置应用程序级别(对整个应用程序有效)的编码. 默认是 UTF-8

* +config.exceptions_app+ 设置异常处理应用程序. 这个应用程序在在异常发生时会被ShowException中间件调用. 默认是 +ActionDispatch::PublicExceptions.new(Rails.pulic_path)+.

* +config.file_watcher+ 被用于监测文件系统里文件更新的类. 在 +config.reload_classes_only_on_change+ 为 true 的时候有效. 多数情况为+ActiveSupport::FileUpdateChecker+ 接口.

* +config.file_parameters+ 用于过滤掉不想被显示在日志里的参数, 比如密码和信用卡号码.

* +config.force_ssl+ 强制所有请求通过+ActionDispath::SSL+中间件使用 HTTPS 协议.

* +config.log_level+ 定义 Rails 日志的冗长程度. 这个选项默认为 +:debug+ 并对所有模式有效,除了生产模式. 生产模式默认为+:info+

* +config.log_tags+ 接受一组方法, 这些方法回应 +request+ 对象. 这样使标记调试信息日志行更容易, 像子域名和请求标示(id) -- 在调试多用户应用程序产品时都很又用.

* +config.logger+ 接受一个日志类, 这个类遵循 +Log4r+ 或者 Ruby 默认的 +logger+ 类的接口. 默认是 +ActiveSupport::BufferedLogger+ 的对象, 在生产模式是关闭的.

* +config.middleware+ 让你配置应用程序的中间件. 这在 "Configuring Middleware":#configuring-middleware 下面的章节又更深入的概述

* +config.preload_frameworks+ 使应用程序在启动时是否能预加载所有的框架. 通过 +config.threadsafe!+ 开启. 默认是 +nil+, 所以是关闭的.

* +config.preload_classes_only_on_change+ 当被监测文件发生改变时,类是否能被重新加载. 设置为 true时, 默认监测所有在自动加载路径的所有东西. 如果 +config.cache_classes+ 为 true, 这个选项会被忽略.

* +config.secret_token+ 用于指定一个键, 这让应用程序的会话会对比已有的密钥被验证以防止干扰.应用程序会让+config/initializers/secret_token.rb+文件里的+config.secret_token+被初始化并产生一个随机键.

* +config.serve_static_assets+ 配置 Rails 自己处理静态资源. 默认为 true, 但在生产环境是被关闭的,因为有服务器软件(e.g. Nginx 或 Apache)用于运行应用程序, 它们会处理静态资源. 不像默认的设置,将其设置为 true, 生产模式下会使用WEBrick运行(完全不建议!)或者测试你的应用. 不然你将不能使用页面缓存,还有对存在于公共目录下文件的请求都会被转给Rails应用.

* +config.session_store+ 通常在 +config/initializers/session_store.rb+ 里设置并指定使用什么类来存储会话. 可能的值会是默认的+:cookie_store+, +:mem_cache_store+, 或 +:disabled+. 最后一个告诉 RAils 不处理会话. 自定义会话存储也可以指定:

<ruby>
config.session_store :my_custom_store
</ruby>

这个自定义存储必须被定义为 +ActionDispatch::Session::MyCustomStore+. 根据这些符号, 它们也可以是实现了某个API的对象, 如 +ActiveRecord::SessionStore+, 这种情况就可以不指定命名域.

h4. 配置资源

Rails 3.1, 默认使用 +sprockets+ gem 来管理资源。这个 gem 合并并压缩资源，为了降低服务器负载。

* +config.assets.enabled+ 是一个标记，这个标记控制是否使用资源通道(asset pipeline)。 这在 +config/application.rb+ 里被明确的初始化了.

* +config.assets.compress+ 标记是否压缩已经编译好的资源。这在+config/production.rb+里明确的设置为 true.

* +config.assets.css_compressor+ 定义要使用的 CSS 压缩器。默认被设置为 +sass-rails+。目前唯一可以选择的值是 +:yui+, 这会使用 +yui-compressor+ gem.

* +config.assets.paths+ 包含了所有用来查找资源的路径。 添加到这个配置选项里的路径，会被用于搜索资源.

* +config.assets.precompile+ 让你指定其它（+application.css+ 和 +application.js+以外的）资源，这些资源会在 +rake assets:precompile+ 执行时被预编译.

* +config.assets.prefix+ 指定资源目录的前缀，默认是+/assets+.

* +config.assets.digest+ 使资源的名字能使用(带有)MD5指纹。 在+production.rb+默认设置为 true.

* +config.assets.debug+ 不合并压缩资源。在 +development.rb+ 里默认不设置为 false

* +config.assets.manifest+ 指定了一个完整的路径，这是资源预编译器的待编译列表文件所在目录的路径。默认使用 +config.assets.prefix+

* +config.assets.cache_store+ 指定 Sprockets 要使用的缓存存储. 默认是Rails的文件存储。

* +config.assets.version+ 是一个字符串选项，用于生成MD5哈希值。可以被更改从而强制所有文件都被预编译.

* +config.assets.compile+ 是一个布尔值，可以用于开启让、 Sprockets 在生产环境的即时执行编译。

* +config.assets.logger+ 接受一个遵循 Log4r 或者 Ruby 默认 +Logger+ 类接口的日志类.默认和 +config.logger+ 指定的一样。设置 +config.assets.logger+ 为 false, 就可以关闭记录资源处理的日志。

h4. 配置生成器

Rails 3 允许你修改在 +config.generators+ 方法被使用到的生成器.这个方法接受一个闭包:

<ruby>
config.generators do |g|
  g.orm :active_record
  g.test_framework :test_unit
end
</ruby>

可以被这个闭包使用的所有方法列表如下:

* +assets+ 允许在创建一个脚手架(scaffold)时候创建资源文件。默认是 +true+
* +force_plural+ 运行将数据模型(model)的名字都变成复数。默认是 +false+
* +helper+ 指定是否要创建帮助器(helpers). 默认是 +true+
* +integration_tool+ 指定使用哪个集成工具。默认是 +nil+
* +javascripts+ 开启生成器中javascript的钩子(hook). 被使用于Rails运行 +scaffold+ 生成器的时候。默认是 +true+。
* +javascript_engine+ 配置用于生成资源的引擎(例如, coffee).默认为 +nil+.
* +orm+ 指定使用哪个orm. 默认是 +false+ 并且默认使用 Active Record.
* +performance_tool+ 指定使用哪个性能工具.默认为+nil+
* +resource_controller+ 指定当使用 +rails generate resource+时,生成控制器的生成器.默认是 +:controller+
* +scaffold_controller+ 和 +resource_controller+不同，指定当使用 +rails generate scaffold+时，生成一个 _scaffolded_ 控制器的生成器。
* +stylesheets+ 开启生成器中的式样钩子。在Rails中被用于 +scaffold+ 生成器运行的时候， 但这个钩子也可以用在其它生成器。默认为 +true+
* +stylesheets_engine+ 配置生成资源的式样引擎(例如, sass)。默认是 +css+
* +test_framework+ 指定使用哪个测试框架。默认为 +false+, 并且默认使用 Test::Unit.
* +template_engine+ 指定使用哪个模板引擎，比如 ERB 或 Haml.默认为 +:erb+.

h4. 配置中间件

所有的Rails应用程序都来自于一系列标准的中间件，这些中间件以下列顺序被使用于开发环境:

* +ActionDispatch::SSL+ 强制所有请求使用HTTPS协议。在 +config.force_ssl+ 被设置为 +true+ 的时候可用。传递给它的选项可以在 +config.ssl_options+ 编辑.
* +ActionDispatch::Static+ 用于处理静态资源。在 +config.serve_static_assets+ 设置为 +true+ 的时候不可用。
* +Rack::Lock+ 将应用封装成互斥体，那么应用程序就一次只能被单个线程调用。只在 +config.action_controller_concurrency+ 设置为 +false+的时候才可用， 这是默认的.
* +ActiveSupport::Cache::StrategyLocalCache+ 作为基础的内存后备缓存器. 这个缓存器不是线程安全的，并且只是作为单个线程的临时内存缓存器。
* +Rack::Runtime+ 设置一个 +X-Runtime+ 头部，包括时间(精确到秒)令牌, 去执行请求。
* +Rails::Rack::Logger+ 通知日志请求已经开始。请求完成后，清除所有的日志。
* +ActionDispatch::ShowExceptions+ 救回(回收)应用程序返回的异常，如果是本地请求或者 +config.consider_all_requests_local+ 设置为 +true+ 的话，还会渲染出漂亮的异常信息页。如果 +config.action_dispatch.show_exceptions+ 设置为 +false+， 抛出的异常会被忽略。
* +ActionDispatch::RequestId+ 产生一个唯一的 X-Request-Id 头部给响应(response)，并使用 +ActionDispatch::Request#uuid+ 方法.
* +ActionDispatch::RemoteIp+ 用于防止IP欺骗攻击。可在 +config.action_dispatch.id_spoofing_check+ 和 +config.action_dispatch.trusted_proxies+ 进行设置.
* +Rack::Sendfile+ 截取所有正文(HTTP 正文)被用于服务于某个文件的响应(responses)，并将其替换成一个服务器指定的 X-Sendfile 头部(HTTP 头部). 可以在 +config.action_dispatch.x_sendfile_header+.
* +ActionDispatch::Callbacks+ 在处理请求之前运行预先准备的回调。
* +ActiveRecord::ConnectionAdapters::ConnectionManagement+ 在每次请求完成后清除连接，除非 +rack.test+ 键在请求的环境设置中设置为 +true+
* +ActiveRecord::QueryCache+ 缓存所有请求中产生的 SELECT 查询。如果换成任何 INSERT 或者 UPDATE 则缓存会被清除.
* +ActionDispatch::Cookies+ 为请求设置 cookies.
* +ActionDispatch::Session::CookieStore+ 负责存储cookies中的会话。通过根据可选值修改 +config.action_controller.session_store+，可以使用其它中间件. 另外，传递给这个中间件的参数可以在 +config.action_controller.session_options+ 配置.
* +ActionDispatch::Flash+ 设置 +flash+ 的键值。只有在 +config.action_controller.session_store+ 设置为某个值才会起作用
* +ActionDispatch::ParamsParser+ 将请求中的参数解析成+params+
* +Rack::MethodOverride+ 允许方法被重写，如果有对 +params[:_method]+ 进行设置。这是提供 PATCH, PUT 和 DELETE 的 HTTP方法类型处理支持的中间件.
* +ActionDispatch::Head+ 将所有HEAD请求转换成GET请求，然后再处理。
* +ActionDispatch::BestStandardsSupport+ 启用 "最好的标准支持" 所以IE8能正确的渲染元素.

除了这些常用的中间件，你可以通过 +config.middleware.use+ 方法添加自己的:

<ruby>
config.middleware.use Magical::Unicorns
</ruby>

这会将 +Magical::Unicorns+ 中间件放置到堆栈的尾部。如果你想添加一个中间件到另一个的前面，可以使用 +insert_before+

<ruby>
config.middleware.insert_before ActionDispatch::Head, Magical::Unicorns
</ruby>

当然也有 +insert_after+，它将把某个中间件插入到另一个的后面:

<ruby>
config.middleware.insert_after ActionDispatch::Head, Magical::Unicorns
</ruby>

所有的中间件也可以被完全移除并替换成其它的:

<ruby>
config.middleware.swap ActionDispatch::BestStandardsSupport, Magical::Unicorns
</ruby>

它们也能完全从堆栈中被移除.
<ruby>
config.middleware.delete ActionDispatch::BestStandardsSupport
</ruby>

除了这些操作堆栈的方法，如果你的应用程序只作为一个API端的话，中间件堆栈可以像这样设置:

<ruby>
config.middleware.http_only!
</ruby>

通过这样做，Rails将会创建一个更小的中间件堆栈，这个堆栈中不会添加一些通常对浏览器访问很有用的中间件, 比如 Cookies, 会话，闪存(Flash), BestStandardsSupport 和 MethodOverride. 你可以手动添加它们。查阅 "API App docs":api_app.html 可以获得更多关于如何设置你API应用程序的信息。

h4. 配置 i18n

* +config.i18n.default_locale+ 设置某个使用i18n应用程序的默认本地语言环境。默认为 +:en+

* +config.i18n.load_path+ 设置Rails用来搜索本地化文件的路径。默认为 +config/locales/*.{yml,rb}+

h4. 配置 Active Record

<tt>config.active_record</tt> 包括了下列配置选项:

* +config.active_record.logger+ 接受一个符合 Log4r 或者 Ruby 默认日志类 接口的日志类, 并会被传递给任何新建立的数据库连接. 你可以通过调用某个Active Record模型类或者某个Active Record模型示例的 +logger+ 对象来取得这个日志类. 默认设置为 +nil+ 来取消日志记录.

* +config.active_record.primary_key_prefix_type+ 让你调整主键栏的名字。默认情况下， Rails假设主键栏是被命名为+id+(这个配置选项不需要设置。) 这有两个其它选择:
** +:table_name+ 会使用自定义的 +customerid+ 类来生成主键
** +:table_name_with_underscore+ 会使用自定义的 +customer_id+ 来生成主键

* +config.active_record.table_name_prefix+ 让你设置一个全局字符串加入到表明中. 如果你这个字符串设置为 +northwest_+, 那么Customer类将找 +northwest_customers+ 表作为它的表. 默认是一个空字符串.

* +config.active_record.table_name_suffix+ 让你为设置一个全局字符串加入到表名中. 如果你将它设置为 +_northwest+, 那么Customer类将会找到 ++customers_northwest+ 作为它的表. 默认是一个空字符串.

* +config.active_record.pluralize_table_names+ 指定Rails是否在数据库中寻找表名是单数的表,还是表名是复数的表. 如果设置为 true (默认值), 那么 Customer 类将会使用 +customers+ 表. 如果设置为 false, 那么 Customer 类将会使用 +customer+ 表.

* +config.active_record.default_timezones+ 当从数据库获取日期和时间时,决定是否使用 +Time.local+ (如果设置为 +:local+) 还是 +Time.utc+ (如果设置为 +:utc+). 虽然活动记录(Active Record)在Rails以外默认为 +:local+, 但在Rails中默认为 +:utc+. 
